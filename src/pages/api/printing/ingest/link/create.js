import clientPromise from '@/lib/mongodb';
import dayjs from '@/lib/time';

import { PrintStates } from '@/util/states';

export default async function handler(req, res) {
    const mongoClient = await clientPromise;

    const body = req.body;

    let input = {
        id: 'assigned_uuid',
        trayName: 'tray_name',
        printer: 'printer_id', // note printer ids can be fetched from GET /api/printing/printers
        estTime: 'PTXHXM', // see https://www.digi.com/resources/documentation/digidocs//90001488-13/reference/r_iso_8601_duration_format.htm, ex. PT2H20M for 2 hours 20 minutes
        materialType: 'material_type', // note material types can be fetched from GET /api/printing/printerTypes
        materialUsage: 0, // integer representing material usage (dw about units)
        timestamp: '2021-09-01T00:00:00.000Z' // some ISO8601 timestamp of when it was queued (best guess). note this MUST BE EARLIER THAN ANY OTHER PRINT EVENTS
    };

    if (req.method === 'POST') {
        const data = body.printData;

        // check if the print already exists
        const existing = await mongoClient.db('printing').collection('print-log').findOne({
            linkedPrintId: data.id
        });

        if (existing) {
            res.status(400).json({
                success: false,
                message: 'Print with matching job id already exists'
            });
            return;
        }

        // prints are in the format (PI)_firstname_lastname_partdescription
        // split it up into each part
        const parts = data.trayName.split('_');

        if (parts.length < 3) {
            res.status(400).json({
                success: false,
                message: 'Print name not in correct format'
            });
            return;
        }

        let firstname, lastname, partDescription;
        if (parts[0].toUpperCase().includes('PI')) {
            firstname = parts[1];
            lastname = parts[2];
            partDescription = parts[3];
        } else {
            firstname = parts[0];
            lastname = parts[1];
            partDescription = parts[2];
        }

        let events = [];
        events.push({
            type: PrintStates.QUEUED,
            timestamp: data?.timestamp || dayjs().utc().toISOString(),
            notes: '[AUTOGENERATED EVENT]'
        });

        const print = await mongoClient
            .db('printing')
            .collection('print-log')
            .insertOne({
                trayName: data.trayName,
                linkedPrintId: data.id,
                printer: data.printer,
                materialType: data.materialType,
                materialUsage: data.materialUsage,
                estTime: data.estTime,

                state: 0,
                notes: '*Autogenerated entry because a matching print could not be found in the logs.*',

                stlFiles: [],

                queuedAt: data?.timestamp || dayjs().utc().toISOString(),
                updatedAt: dayjs().utc().toISOString(),
                queuedBy: 'AUTOMATED',
                endUser: {
                    firstname: firstname,
                    lastname: lastname,
                    email: ''
                },

                events: events
            });

        // add to printer's queue
        const printer = await mongoClient
            .db('printing')
            .collection('printers')
            .findOneAndUpdate(
                { id: data.printer },
                {
                    $push: {
                        queue: {
                            // push it to the front of the queue
                            $each: [print.insertedId.toString()],
                            $position: 0
                        }
                    }
                }
            );

        res.status(200).json({
            success: true,
            printId: print.insertedId.toString()
        });
    }
}
